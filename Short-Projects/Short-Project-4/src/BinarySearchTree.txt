/** @author 
 *  Binary search tree (starter code)
 **/

import java.util.*;


public class BinarySearchTree<T extends Comparable<? super T>> implements Iterable<T> {
    static class Entry<T> {
        T element;
        Entry<T> left, right;

        public Entry(T x, Entry<T> left, Entry<T> right) {
            this.element = x;
	    this.left = left;
	    this.right = right;
        }
        public T getE(){
            return element;
        }
    }
    
    Entry<T> root;
    int size;
    Deque<Entry<T>> stack;
    Iterator<T> it;
    Comparator<T> comp = (T a, T b) -> a.compareTo(b);
    int position;

    public Iterator<T> iterator() {
        return null;
    }





    public BinarySearchTree() {
        root = null;
        size = 0;
        stack = new ArrayDeque<>(100);
    }


    public Entry<T> find(T x){
        //Entry[] stack = new Entry[100];
        stack.clear();
        stack.push(new Entry<>(null, null, null));
        return find(root, x);
    }

    public Entry<T> find(Entry<T> x, T element){
        if (x == null || comp.compare(x.getE(), element) == 0){
            return x;
        }
        while (true){
            if (comp.compare(element, x.element) < 0){
                if(x.left == null){
                    break;
                }
                stack.push(x);
                x = x.left;
            }
            else if(comp.compare(element, x.element) == 0){
                break;
            }
            else{
                if (x.right == null){
                    break;
                }
                stack.push(x);
                x = x.right;
            }
        }
        return x;
    }




    /** TO DO: Is x contained in tree?
     */
    public boolean contains(T x) {
        Entry<T> element = find(x);
        if (element == null || comp.compare(element.element, x) != 0){
            return false;
        }
        return true;
    }

    /** TO DO: Is there an element that is equal to x in the tree?
     *  Element in tree that is equal to x is returned, null otherwise.
     */
    public T get(T x) {
	return null;
    }

    /** TO DO: Add x to tree. 
     *  If tree contains a node with same key, replace element by x.
     *  Returns true if x is a new element added to tree.
     */
    public boolean add(T x) {
        Entry<T> element, newEntry;
        if (size == 0){
            root = new Entry<>(x, null, null);
            size = 1;
            return true;
        }
        else{
            stack.clear();
            element = find(x);
            if (element.element == x){
                newEntry = new Entry(x, element.left, element.right);
                element = newEntry;
                return false;
            }
            else {
                newEntry = new Entry<>(x, null, null);
                if (comp.compare(x, (T)element.getE()) > 0){
                    element.right = newEntry;
                }
                else{
                    element.left = newEntry;
                }
                size++;
                return true;
            }
        }
    }

    /** TO DO: Remove x from tree. 
     *  Return x if found, otherwise return null
     */
    public T remove(T x) {
        Entry minRight;
        T result;
        stack.clear();

        if (size == 0){
            return null;
        }
        Entry t = find(x);

        if (comp.compare(x, (T)t.getE()) != 0) {
            return null;
        }
        result = (T)t.getE();
        if (t.left == null || t.right == null){
            bypass(t);
        }
        else{
            stack.clear();
            stack.push(t);
            minRight = find(t.right, (T)t.getE());
            t.element = minRight.element;
            bypass(minRight);
        }
        size--;
        return result;
    }

    public void bypass(Entry t){
        Entry parent = stack.peek();
        Entry child = t.left == null? t.right: t.left;

        if (parent == null){

            root = child;
        }
        else if (parent.left == t){
            parent.left = child;
        }
        else{
            parent.right = child;
        }
    }

    public T min() {
	    if (size == 0){
	        return null;
        }
        Entry<T> t = root;
        while (t.left != null){
            t = t.left;
        }
        return t.element;
    }

    public T max() {
        if (size == 0){
            return null;
        }
        Entry<T> t = root;
        while(t.right != null){
            t = t.right;
        }
        return t.element;
    }

    // TODO: Create an array with the elements using in-order traversal of tree


    public Comparable[] toArray(){
        position = 0;
        Comparable[] arr = new Comparable[size];
        populate(root, arr);
        return arr;
    }

    public void populate(Entry<T> node, Comparable[] arr){
        if (node != null){
            populate(node.left, arr);
            arr[position] = node.element;
            position++;
            populate(node.right, arr);
        }
    }


    // Inorder traversal of tree
    void printTree(Entry<T> node) {
        if (node != null) {
            printTree(node.left);
            System.out.print(" " + node.element);
            printTree(node.right);
        }
    }


    public void printTree() {
        System.out.print("[" + size + "]");
        printTree(root);
        System.out.println();
    }

    /** floor and ceiling; should I just consider t's right and left child or can I consider the parent's other child too?
     * */

    public void findElement(T x){
        Entry<T> t = root;
        while(true){
            if (comp.compare(x, t.element) < 0){
                if (t.left == null){
                    break;
                }
                t = t.left;
            }
            else if (comp.compare(x, t.element) == 0){
                break;
            }
            else{
                if (t.right == null){
                    break;
                }
                t = t.right;
            }


        }
        System.out.println("T element:" + t.element);
    }


    // Optional problem 2.  Find largest key that is no bigger than x.  Return null if there is no such key.
    public T floor(T x) {
        Entry<T> t;
        if (!contains(x)){
            findElement(x);
        }
/*
        Entry<T> t = find(x);







        System.out.println(t.element);
        if (t.left == null){
            return null;
        }
        t = t.left;
        while(t.right != null){
            t = t.right;
        }

        return t.element;
        */
    return null;
    }

    // Optional problem 2.  Find smallest key that is no smaller than x.  Return null if there is no such key.
    public T ceiling(T x) {
        Entry<T> t = find(x);
        System.out.println(t.element);
        if (t.right == null){
            return null;
        }
        t = t.right;
        while(t.left != null){
            t = t.left;
        }

        return t.element;
    }

    // Optional problem 2.  Find predecessor of x.  If x is not in the tree, return floor(x).  Return null if there is no such key.
    public T predecessor(T x) {
        //Entry<T> t = find(x);

        if (!contains(x)){
            return floor(x);
        }

        /*

        if (t == null){
            return floor(x);
        }
        System.out.println("t element:" + t.element);

        System.out.println(x);
        if (t.left != null){
            t = t.left;

            while (t.right != null){
                t = t.right;
            }

            return  t.element;
        }
        return null;
        */
        return null;
    }

    // Optional problem 2.  Find successor of x.  If x is not in the tree, return ceiling(x).  Return null if there is no such key.
    public T successor(T x) {
        Entry<T> t = find(x);

        if (t == null){
            return ceiling(x);
        }


        if (t.right != null){
            t = t.right;

            while (t.left != null){
                t = t.left;
            }

            return  t.element;
        }
        return null;
    }


    public static void main(String[] args) {


        BinarySearchTree<Integer> obj = new BinarySearchTree<>();

        Random rand = new Random();
        int [] arr = new int[20];


        for (int i = 0; i < 20; i++){
            int random = rand.nextInt(100000);
            obj.add(random);
            arr[i] = random;
        }
        for (int item: arr){
            System.out.print(" " + item);
        }
        System.out.println();
        obj.printTree();
        System.out.println(obj.remove(arr[rand.nextInt(obj.size)]));
        obj.printTree();
        //Integer flr = obj.floor(arr[rand.nextInt(obj.size)]);
        //Integer clng = obj.ceiling(arr[rand.nextInt(obj.size)]);

        //System.out.println("floor:" + flr + " ceiling:" + clng);
        System.out.println("floor:" + obj.floor(23423));

        System.out.println("Predec:" + obj.predecessor(23423));//arr[rand.nextInt(obj.size)]));
        /*
        obj.add(125);
        obj.add(765);
        obj.add(873);
        obj.add(128);
        obj.add(98);
        obj.add(145);
        obj.add(982);
        obj.add(4567);




        obj.printTree(obj.root);
        System.out.println();
        Comparable arr[] = obj.toArray();
        for (Comparable item: arr){
            System.out.print(item + " ");
        }
        System.out.println("Min:" + obj.min());
        System.out.println("Max:" + obj.max());

        System.out.println();
        obj.remove(765);
        obj.printTree(obj.root);


    /*
	BinarySearchTree<Integer> t = new BinarySearchTree<>();
        Scanner in = new Scanner(System.in);
        while(in.hasNext()) {
            int x = in.nextInt();
            if(x > 0) {
                System.out.print("Add " + x + " : ");
                t.add(x);
                t.printTree();
            } else if(x < 0) {
                System.out.print("Remove " + x + " : ");
                t.remove(Math.abs(x));
                t.printTree();
            } else {
                Comparable[] arr = t.toArray();
                System.out.print("Final: ");
                for(int i=0; i<t.size; i++) {
                    System.out.print(arr[i] + " ");
                }
                System.out.println();
                return;
            }           
        }
        */

    }



}


/*
Sample input:
1 3 5 7 9 2 4 6 8 10 -3 -6 -3 0

Output:
Add 1 : [1] 1
Add 3 : [2] 1 3
Add 5 : [3] 1 3 5
Add 7 : [4] 1 3 5 7
Add 9 : [5] 1 3 5 7 9
Add 2 : [6] 1 2 3 5 7 9
Add 4 : [7] 1 2 3 4 5 7 9
Add 6 : [8] 1 2 3 4 5 6 7 9
Add 8 : [9] 1 2 3 4 5 6 7 8 9
Add 10 : [10] 1 2 3 4 5 6 7 8 9 10
Remove -3 : [9] 1 2 4 5 6 7 8 9 10
Remove -6 : [8] 1 2 4 5 7 8 9 10
Remove -3 : [8] 1 2 4 5 7 8 9 10
Final: 1 2 4 5 7 8 9 10 

*/
